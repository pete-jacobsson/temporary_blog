single_cals_log_results_bin20 <- data.frame()
single_cals_log_diagnostics_bin20 <- data.frame()
for (model in model_names) {
## This will get a little experimental - we are trying to create a big old table!
## First, we thin down the DF to the model of interest
temp_results <- single_cals_modelled_bin20 %>%
select(1, 2, all_of(model)) %>% #All of used to address deprecation
rename(glm_list = 3) %>% #This rename allows map to work correctly
mutate(
logistic_results = map(glm_list, tidy), # Do the map and also take note of which model
model = model
) %>%
select(-glm_list) %>% # Gets rid of the actual models (necessary for saving as csv)
unnest(logistic_results)# Unnests results
temp_diagnostics <- single_cals_modelled_bin20 %>% ## Similar to above
select(1, 2, all_of(model)) %>%
rename(glm_list = 3) %>%
mutate(
logistic_diagnostics = map(glm_list, glance),
model = model
) %>%
select(-glm_list) %>%
unnest(logistic_diagnostics)
single_cals_log_results_bin20 <- rbind(single_cals_log_results_bin20,
temp_results)
single_cals_log_diagnostics_bin20 <- rbind(single_cals_log_diagnostics_bin20,
temp_diagnostics)
}
single_cals_log_results_bin20 %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = model), alpha = 0.2, color = "grey75") +
geom_line(aes(color = model), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(colour = "grey80", size = 0.1),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", size = 0.5),
legend.position = "none",
strip.background = element_rect(
color="white", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue")) +
scale_color_manual(values = c("steelblue", "darkblue"))
###Change to 10 bins
single_cals_modelled_bin10 <- single_cals %>%
mutate (
offset_pos = if_else(offset_magnitude > 0, TRUE, FALSE),
offset_magnitude = if_else(offset_pos,
offset_magnitude, offset_magnitude * -1),
# Changing negs on offset magnitude to have a consistent direction at downstream visualization.
binned_targets = ntile(target_year, 10)
) %>%
select(-target_year)
### ntile() wouldn't return the relevant target years, so it needs to be done as its own thing.
single_cals_modelled_bin10 <- single_cals %>%
mutate(binned_targets = ntile(target_year, 10)) %>%
group_by(binned_targets) %>%
summarize( #Easy way to get years for the indiv bins, without too muchj headach
target_year = min(target_year)
) %>%
inner_join(single_cals_modelled_bin10) %>% #Join the binned DF back in. No, I don't like this either!
group_by(offset_pos, target_year) %>%
nest()
### Execute models
single_cals_modelled_bin10 <- single_cals_modelled_bin10 %>%
mutate(
offset_only_acc68 = map(data, offset_only_acc68),
sigma_only_acc68 = map(data, sigma_only_acc68),
offset_sigma_acc68 = map(data, offset_sigma_acc68),
offset_sigma_interact_acc68 = map(data, offset_sigma_interact_acc68),
offset_only_acc95 = map(data, offset_only_acc95),
sigma_only_acc95 = map(data, sigma_only_acc95),
offset_sigma_acc95 = map(data, offset_sigma_acc95),
offset_sigma_interact_acc95 = map(data, offset_sigma_interact_acc95)
)
### Extract the parameters
model_names_bin10 <- colnames(single_cals_modelled_bin10)[4:11] ##These will tell us what results go with what model
single_cals_log_results_bin10 <- data.frame()
single_cals_log_diagnostics_bin10 <- data.frame()
for (model in model_names) {
## This will get a little experimental - we are trying to create a big old table!
## First, we thin down the DF to the model of interest
temp_results <- single_cals_modelled_bin10 %>%
select(1, 2, all_of(model)) %>% #All of used to address deprecation
rename(glm_list = 3) %>% #This rename allows map to work correctly
mutate(
logistic_results = map(glm_list, tidy), # Do the map and also take note of which model
model = model
) %>%
select(-glm_list) %>% # Gets rid of the actual models (necessary for saving as csv)
unnest(logistic_results)# Unnests results
temp_diagnostics <- single_cals_modelled_bin10 %>% ## Similar to above
select(1, 2, all_of(model)) %>%
rename(glm_list = 3) %>%
mutate(
logistic_diagnostics = map(glm_list, glance),
model = model
) %>%
select(-glm_list) %>%
unnest(logistic_diagnostics)
single_cals_log_results_bin10 <- rbind(single_cals_log_results_bin10,
temp_results)
single_cals_log_diagnostics_bin10 <- rbind(single_cals_log_diagnostics_bin10,
temp_diagnostics)
}
single_cals_log_results_bin10 %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = model), alpha = 0.2, color = "grey75") +
geom_line(aes(color = model), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(colour = "grey80", size = 0.1),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", size = 0.5),
legend.position = "none",
strip.background = element_rect(
color="white", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue")) +
scale_color_manual(values = c("steelblue", "darkblue"))
single_cals_log_results_bin10 %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = model), alpha = 0.2, color = "grey75") +
geom_line(aes(color = model), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
strip.background = element_rect(
color="black", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue")) +
labs(
subtitle = "Intercept estimates from the models containing an interaction term",
x = "Target Date (Cal BP)"
)
## Get model diagnostics
### Set-up for fifty bins
singles_data_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/simulation_results/single_cals_curve_uncert_diag.csv"
single_cals <- read_csv(url(singles_data_url))
library(tidyverse)
library(broom)
## Get model diagnostics
### Set-up for fifty bins
model_diags_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/simulation_results/single_cals_curve_uncert_diag.csv"
model_diags <- read_csv(url(singles_data_url))
## Get model diagnostics
### Set-up for fifty bins
model_diags_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/model_results/single_cals_curve_uncert_diag.csv"
model_diags <- read_csv(url(singles_data_url))
model_diags <- read_csv(url(model_diags_url))
## Get model diagnostics
### Set-up for fifty bins
model_diags_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/model_results/single_cals_curve_uncert_diag.csv"
single_cals_curve_uncert_diag <- read_csv(url(model_diags_url))
single_cals_curve_uncert_diag %>%
mutate(
offset_direction = if_else(is_pos, "Positive", "Negative"),
hpd_area = if_else(str_detect(model, "68"), "68.2% HPD Area", "95.4% HPD Area"),
model = str_remove_all(model, "_acc\\d{2}")
) %>%
ggplot(aes(x = model, y = AIC)) +
geom_bar(stat = "identity", fill = "steelblue", color = "grey40") +
facet_grid(rows = vars(hpd_area), cols = vars(offset_direction), scales = "free") +
labs(
x = "Model",
subtitle = "AIC of different models that include curve uncertainty"
) +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", size = 0.5),
#legend.position = "none",
strip.background = element_rect(
color="white", fill="white"
),
text = element_text(family = "Corbel"),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 9)
)
library(jtools)
library(tidyverse)
predict_model_results_osc <- function(offset_dir, hpd_area, model_name,
variable, variable_range) {
##Function to simplify prediction generation
##Takes on offset_dir and hpd_area, which simplify the results table,
##Takes on variable name as string and variable range as a sequence
##Assumes offset dir, hpd_area, and variable name provided are all correct
offset_curve_sigma_os <- readRDS("single_cals_curve_uncert_regr.rds") %>%
filter(str_detect(model, model_name)) %>%
mutate(is_pos = if_else(is_pos, "positive", "negative")) %>% ## Change type for filtering
filter(str_detect(is_pos, offset_dir) & str_detect(model, hpd_area))
predicted_results <- make_predictions(offset_curve_sigma_os$model_results[[1]],
pred = variable,
pred.values = variable_range)
predicted_results
}
predict_model_results_osc(offset_dir = "pos", hpd_area = "68",
model_name = "offset_curve_interact",
variable = "offset_magnitude",
variable_range = seq(0, 50))
predict_model_results_osc <- function(offset_dir, hpd_area, model_name,
variable, variable_range) {
##Function to simplify prediction generation
##Takes on offset_dir and hpd_area, which simplify the results table,
##Takes on variable name as string and variable range as a sequence
##Assumes offset dir, hpd_area, and variable name provided are all correct
offset_curve_sigma_os <- readRDS("single_cals_curve_uncert_regr.rds") %>%
filter(str_detect(model, model_name)) %>%
mutate(is_pos = if_else(is_pos, "positive", "negative")) %>% ## Change type for filtering
filter(str_detect(is_pos, offset_dir) & str_detect(model, hpd_area))
predicted_results <- make_predictions(offset_curve_sigma_os$model_results[[1]],
pred = variable,
pred.values = variable_range)
predicted_results
}
predict_model_results_osc(offset_dir = "pos", hpd_area = "68",
model_name = "offset_curve_interact",
variable = "offset_magnitude",
variable_range = seq(0, 50))
plot_simulation_results_osc <- function(range_to_plot, hpd_area, variable,
rounding, xlab) {
##This function plots the simulation results for the purposes of the results graphing
single_cals_curve_uncert_mod <- read_csv("single_cals_w_curve_uncert.csv") %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_curve_uncert_mod %>%
rename(variable_to_plot = variable, hpd_to_plot = hpd_area) %>%
filter(variable_to_plot >= range_to_plot[1] &
variable_to_plot <= range_to_plot) %>%
mutate(
variable_to_plot = plyr::round_any(variable_to_plot, rounding)
) %>%
select(variable_to_plot, hpd_to_plot) %>%
group_by(variable_to_plot) %>%
summarize(
ratio_accurate = mean(hpd_to_plot)
) %>%
ggplot(aes(x = variable_to_plot, y = ratio_accurate)) +
geom_bar(stat = 'identity', fill = "steelblue") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", linewidth = 0.5),
text = element_text(family = "Corbel")#,
#axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 9)
) +
labs(
y = "Ratio accurate",
x = xlab
)
}
plot_model_predictions_ocs <- function(offset_dir, hpd_area, model_name, variable,
range, rounding, xlab) {
## This function wraps predict_model_results and plot_simulation_results and plots prediction over simulation.
## parameters and assumptions as per underpinning functions.
plot <- plot_simulation_results_osc(range_to_plot = range, hpd_area = hpd_area,
variable = variable, rounding = rounding,
xlab = xlab)
hpd_for_predict = str_extract(hpd_area, "\\d{2}") ## predict_model_results only takes two-digit numbers as input here (for filtering) - this extracts from HPD area above
predicts_tab <- predict_model_results_osc(offset_dir = offset_dir,
hpd_area = hpd_for_predict,
model_name = model_name,
variable = variable,
variable_range = seq(range[1],
range[2]))
predicts_tab <- predicts_tab %>%
rename("variable_to_plot" = variable, ratio_accurate = 1) ##Dovetail the variable names for the plot at the iteration where interactions start getting explored
plot <- plot +
geom_line(data = predicts_tab)
plot
}
plot_simulation_results_osc <- function(range_to_plot, hpd_area, variable,
rounding, xlab) {
##This function plots the simulation results for the purposes of the results graphing
single_cals_curve_uncert_mod <- read_csv(
url("https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/single_cals_w_curve_uncert.csv")) %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_curve_uncert_mod %>%
rename(variable_to_plot = variable, hpd_to_plot = hpd_area) %>%
filter(variable_to_plot >= range_to_plot[1] &
variable_to_plot <= range_to_plot) %>%
mutate(
variable_to_plot = plyr::round_any(variable_to_plot, rounding)
) %>%
select(variable_to_plot, hpd_to_plot) %>%
group_by(variable_to_plot) %>%
summarize(
ratio_accurate = mean(hpd_to_plot)
) %>%
ggplot(aes(x = variable_to_plot, y = ratio_accurate)) +
geom_bar(stat = 'identity', fill = "steelblue") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", linewidth = 0.5),
text = element_text(family = "Corbel")#,
#axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 9)
) +
labs(
y = "Ratio accurate",
x = xlab
)
}
plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
plot_model_predictions_ocs <- function(offset_dir, hpd_area, model_name, variable,
range, rounding, xlab) {
## This function wraps predict_model_results and plot_simulation_results and plots prediction over simulation.
## parameters and assumptions as per underpinning functions.
plot <- plot_simulation_results_osc(range_to_plot = range, hpd_area = hpd_area,
variable = variable, rounding = rounding,
xlab = xlab)
hpd_for_predict = str_extract(hpd_area, "\\d{2}") ## predict_model_results only takes two-digit numbers as input here (for filtering) - this extracts from HPD area above
predicts_tab <- predict_model_results_osc(offset_dir = offset_dir,
hpd_area = hpd_for_predict,
model_name = model_name,
variable = variable,
variable_range = seq(range[1],
range[2]))
predicts_tab <- predicts_tab %>%
rename("variable_to_plot" = variable, ratio_accurate = 1) ##Dovetail the variable names for the plot at the iteration where interactions start getting explored
plot <- plot +
geom_line(data = predicts_tab)
plot
}
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
model_name = "act_oc_sc_acc",
variable = "offset_magnitude",
range = c(0, 50), rounding = 2.5,
xlab = "Offset magnitude")
install.packages("patchwork")
install.packages("gapminder")
library("patchwork")
library(tidyverse)
library(jtools)
library(patchwork)
p1 <- plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
variable = "curve_uncert",
range = c(10, 30), rounding = 2.5,
xlab = "Curve uncertainty")
p1 <- plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
variable = "curve_uncert",
model_name = "oc_sc_ocs",
range = c(10, 30), rounding = 2.5,
xlab = "Curve uncertainty")
p1
p1 <- plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
variable = "curve_uncert",
model_name = "os_acc",
range = c(10, 30), rounding = 2.5,
xlab = "Curve uncertainty")
p1
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_95",
variable = "measurement_error",
model_name = "os_cs",
range = c(8, 32), rounding = 2,
xlab = "Measurement error") +
labs(
title = "Ratio accurate determinations in simulated sample and the fitted regression line",
caption = "Define: 'Model does not match the data'"
)
install.packages("kable")
offset_curve_sigma_comb_interact_params <- readRDS("single_cals_curve_uncert_regr.rds") %>%
filter(str_detect(model, "comb_inter")) %>%
mutate(model_results = map(model_results, tidy)) %>%
unnest(cols = c(model_results))
library(broom)
offset_curve_sigma_comb_interact_params <- readRDS("single_cals_curve_uncert_regr.rds") %>%
filter(str_detect(model, "comb_inter")) %>%
mutate(model_results = map(model_results, tidy)) %>%
unnest(cols = c(model_results))
knitr::kable(
offset_curve_sigma_comb_interact_params %>%
filter(str_detect(term, "Interce")) %>%
select(is_pos, model, estimate) %>%
mutate(acc_zero = 1 / (1 + exp(- estimate)))
)
knitr::kable(
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate) |>
mutate(
`Offset direction` = if_else(is_pos, "Positive", "Negative")
) |>
mutate(acc_zero = 1 / (1 + exp(- estimate)))
)
knitr::kable(
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate) |>
mutate(
`Offset direction` = if_else(is_pos, "Positive", "Negative"),
Model = str_extract(model, "acc\\d{2}")
) |>
mutate(acc_zero = 1 / (1 + exp(- estimate)))
)
knitr::kable(
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate) |>
mutate(
`Offset direction` = if_else(is_pos, "Positive", "Negative"),
Model = str_extract(model, "acc\\d{2}")
) |>
select(-is_pos, -model) |>
mutate(acc_zero = 1 / (1 + exp(- estimate)))
)
knitr::kable(
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate, std.error) |>
mutate(
acc_zero = 1 / (1 + exp(- estimate)),
acc_zero_min = 1 / (1 + exp(- (estimate - 2 * std.error))),
acc_zero_max = 1 / (1 + exp(- (estimate + 2 * std.error))),
) |>
mutate(
`Offset direction` = if_else(is_pos, "Positive", "Negative"),
Model = str_extract(model, "acc\\d{2}")
) |>
select(`Offset direction`, Model, estimate) |>
mutate(acc_zero = 1 / (1 + exp(- estimate)))
)
knitr::kable(
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate, std.error) |>
mutate(
acc_zero = 1 / (1 + exp(- estimate)),
acc_zero_min = 1 / (1 + exp(- (estimate - 2 * std.error))),
acc_zero_max = 1 / (1 + exp(- (estimate + 2 * std.error))),
) |>
mutate(
`Offset direction` = if_else(is_pos, "Positive", "Negative"),
Model = str_extract(model, "acc\\d{2}")
) |>
select(`Offset direction`, Model, acc_zero, acc_zero_min, acc_zero_max) |>
mutate(acc_zero = 1 / (1 + exp(- estimate)))
)
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate, std.error) |>
mutate(
acc_zero = 1 / (1 + exp(- estimate)),
acc_zero_min = 1 / (1 + exp(- (estimate - 2 * std.error))),
acc_zero_max = 1 / (1 + exp(- (estimate + 2 * std.error))),
)
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate, std.error) |>
mutate(
acc_zero = 1 / (1 + exp(- estimate)),
acc_zero_min = 1 / (1 + exp(- (estimate - 2 * std.error))),
acc_zero_max = 1 / (1 + exp(- (estimate + 2 * std.error))),
) |>
mutate(
`Offset direction` = if_else(is_pos, "Positive", "Negative"),
Model = str_extract(model, "acc\\d{2}")
) |>
select(`Offset direction`, Model, acc_zero, acc_zero_min, acc_zero_max)
knitr::kable(
offset_curve_sigma_comb_interact_params |>
filter(str_detect(term, "Interce")) |>
select(is_pos, model, estimate, std.error) |>
mutate(
acc_zero = 1 / (1 + exp(- estimate)),
acc_zero_min = 1 / (1 + exp(- (estimate - 2 * std.error))),
acc_zero_max = 1 / (1 + exp(- (estimate + 2 * std.error))),
) |>
mutate(
`Offset direction` = if_else(is_pos, "Positive", "Negative"),
Model = str_extract(model, "acc\\d{2}")
) |>
select(`Offset direction`, Model, acc_zero, acc_zero_min, acc_zero_max)
)
