scale_fill_manual(name = "Parameter", values = c("steelblue", "grey50", "darkblue")) +
scale_color_discrete(name = "Parameter") +
labs(
subtitle = "Estimates for the models without and with an interaction term",
x = "Target year (cal BP)",
caption = "Please note: visualization only contains model with positive offsets"
)
single_cals_log_results %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
filter(!(target_year %in% c(7019, 7751, 9076, 11091) &
str_detect(model, "95"))) %>%  ## This removes extreme values of the 95% model in the visualizations
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_hline(yintercept = 0) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = offset_pos), alpha = 0.2, color = "grey75") +
geom_line(aes(color = offset_pos), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
strip.background = element_rect(
color="black", fill="white"
),
text = element_text(family = "Corbel")
)
single_cals_log_results %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
filter(!(target_year %in% c(7019, 7751, 9076, 11091) &
str_detect(model, "95"))) %>%  ## This removes extreme values of the 95% model in the visualizations
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_hline(yintercept = 0) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = offset_pos), alpha = 0.2, color = "grey75") +
geom_line(aes(color = offset_pos), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
strip.background = element_rect(
color="black", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue"))
single_cals_log_results %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
filter(!(target_year %in% c(7019, 7751, 9076, 11091) &
str_detect(model, "95"))) %>%  ## This removes extreme values of the 95% model in the visualizations
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_hline(yintercept = 0) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = offset_pos), alpha = 0.2, color = "grey75") +
geom_line(aes(color = offset_pos), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
strip.background = element_rect(
color="black", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue")) +
labs(
subtitle = "Intercept estimates from the models containing an interaction term",
x = "Target Date (Cal BP)"
)
### Set-up for fifty bins
singles_data_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/simulation_results/singles_011_results.csv"
single_cals <- read_csv(url(singles_data_url))
library(tidyverse)
library(broom)
### Set-up for fifty bins
singles_data_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/simulation_results/singles_011_results.csv"
single_cals <- read_csv(url(singles_data_url))
###Seperate pos from neg offsets and group things by cal curve
single_cals_modelled <- single_cals %>%
mutate (
offset_pos = if_else(offset_magnitude > 0, TRUE, FALSE),
offset_magnitude = if_else(offset_pos,
offset_magnitude, offset_magnitude * -1),
# Changing negs on offset magnitude to have a consistent direction at downstream visualization.
binned_targets = ntile(target_year, 50)
) %>%
select(-target_year)
### ntile() wouldn't return the relevant target years, so it needs to be done as its own thing.
single_cals_modelled <- single_cals %>%
mutate(binned_targets = ntile(target_year, 50)) %>%
group_by(binned_targets) %>%
summarize( #Easy way to get years for the indiv bins, without too muchj headach
target_year = min(target_year)
) %>%
inner_join(single_cals_modelled) %>% #Join the binned DF back in. No, I don't like this either!
group_by(offset_pos, target_year) %>%
nest()
### Build the model functions
offset_only_acc68 <- function(singles_data) {
glm(accuracy_68 ~ offset_magnitude, data = singles_data,
family = binomial)
}
sigma_only_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error, data = singles_data,
family = binomial)
}
offset_sigma_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude, data = singles_data,
family = binomial)
}
offset_sigma_interact_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude +
measurement_error * offset_magnitude,
data = singles_data, family = binomial)
}
offset_only_acc95 <- function(singles_data) {
glm(accuracy_95 ~ offset_magnitude, data = singles_data,
family = binomial)
}
sigma_only_acc95 <- function(singles_data) {
glm(accuracy_95 ~ measurement_error, data = singles_data,
family = binomial)
}
offset_sigma_acc95 <- function(singles_data) {
glm(accuracy_95 ~ measurement_error + offset_magnitude, data = singles_data,
family = binomial)
}
offset_sigma_interact_acc95 <- function(singles_data) {
glm(accuracy_95 ~ measurement_error + offset_magnitude +
measurement_error * offset_magnitude,
data = singles_data, family = binomial)
}
## Note to future self: some smart pivoting earlier on could have simplified this by half :)
### Model execution
single_cals_modelled <- single_cals_modelled %>%
mutate(
offset_only_acc68 = map(data, offset_only_acc68),
sigma_only_acc68 = map(data, sigma_only_acc68),
offset_sigma_acc68 = map(data, offset_sigma_acc68),
offset_sigma_interact_acc68 = map(data, offset_sigma_interact_acc68),
offset_only_acc95 = map(data, offset_only_acc95),
sigma_only_acc95 = map(data, sigma_only_acc95),
offset_sigma_acc95 = map(data, offset_sigma_acc95),
offset_sigma_interact_acc95 = map(data, offset_sigma_interact_acc95)
)
### Now get the numbers out of the models - aka the actual hard bit XP
model_names <- colnames(single_cals_modelled)[4:11] ##These will tell us what results go with what model
single_cals_log_results <- data.frame()
single_cals_log_diagnostics <- data.frame()
for (model in model_names) {
## This will get a little experimental - we are trying to create a big old table!
## First, we thin down the DF to the model of interest
temp_results <- single_cals_modelled %>%
select(1, 2, all_of(model)) %>% #All of used to address deprecation
rename(glm_list = 3) %>% #This rename allows map to work correctly
mutate(
logistic_results = map(glm_list, tidy), # Do the map and also take note of which model
model = model
) %>%
select(-glm_list) %>% # Gets rid of the actual models (necessary for saving as csv)
unnest(logistic_results)# Unnests results
temp_diagnostics <- single_cals_modelled %>% ## Similar to above
select(1, 2, all_of(model)) %>%
rename(glm_list = 3) %>%
mutate(
logistic_diagnostics = map(glm_list, glance),
model = model
) %>%
select(-glm_list) %>%
unnest(logistic_diagnostics)
single_cals_log_results <- rbind(single_cals_log_results, temp_results)
single_cals_log_diagnostics <- rbind(single_cals_log_diagnostics,
temp_diagnostics)
}
###Change to 20 bins
single_cals_modelled_bin20 <- single_cals %>%
mutate (
offset_pos = if_else(offset_magnitude > 0, TRUE, FALSE),
offset_magnitude = if_else(offset_pos,
offset_magnitude, offset_magnitude * -1),
# Changing negs on offset magnitude to have a consistent direction at downstream visualization.
binned_targets = ntile(target_year, 20)
) %>%
select(-target_year)
### ntile() wouldn't return the relevant target years, so it needs to be done as its own thing.
single_cals_modelled_bin20 <- single_cals %>%
mutate(binned_targets = ntile(target_year, 20)) %>%
group_by(binned_targets) %>%
summarize( #Easy way to get years for the indiv bins, without too muchj headach
target_year = min(target_year)
) %>%
inner_join(single_cals_modelled) %>% #Join the binned DF back in. No, I don't like this either!
group_by(offset_pos, target_year) %>%
nest()
### Execute models
single_cals_modelled_bin20 <- single_cals_modelled_bin20 %>%
mutate(
offset_only_acc68 = map(data, offset_only_acc68),
sigma_only_acc68 = map(data, sigma_only_acc68),
offset_sigma_acc68 = map(data, offset_sigma_acc68),
offset_sigma_interact_acc68 = map(data, offset_sigma_interact_acc68),
offset_only_acc95 = map(data, offset_only_acc95),
sigma_only_acc95 = map(data, sigma_only_acc95),
offset_sigma_acc95 = map(data, offset_sigma_acc95),
offset_sigma_interact_acc95 = map(data, offset_sigma_interact_acc95)
)
### Model execution
single_cals_modelled <- single_cals_modelled %>%
mutate(
offset_only_acc68 = map(data, offset_only_acc68),
sigma_only_acc68 = map(data, sigma_only_acc68),
offset_sigma_acc68 = map(data, offset_sigma_acc68),
offset_sigma_interact_acc68 = map(data, offset_sigma_interact_acc68),
offset_only_acc95 = map(data, offset_only_acc95),
sigma_only_acc95 = map(data, sigma_only_acc95),
offset_sigma_acc95 = map(data, offset_sigma_acc95),
offset_sigma_interact_acc95 = map(data, offset_sigma_interact_acc95)
)
### Set-up for fifty bins
singles_data_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/simulation_results/singles_011_results.csv"
single_cals <- read_csv(url(singles_data_url))
###Seperate pos from neg offsets and group things by cal curve
single_cals_modelled <- single_cals %>%
mutate (
offset_pos = if_else(offset_magnitude > 0, TRUE, FALSE),
offset_magnitude = if_else(offset_pos,
offset_magnitude, offset_magnitude * -1),
# Changing negs on offset magnitude to have a consistent direction at downstream visualization.
binned_targets = ntile(target_year, 50)
) %>%
select(-target_year)
### ntile() wouldn't return the relevant target years, so it needs to be done as its own thing.
single_cals_modelled <- single_cals %>%
mutate(binned_targets = ntile(target_year, 50)) %>%
group_by(binned_targets) %>%
summarize( #Easy way to get years for the indiv bins, without too muchj headach
target_year = min(target_year)
) %>%
inner_join(single_cals_modelled) %>% #Join the binned DF back in. No, I don't like this either!
group_by(offset_pos, target_year) %>%
nest()
### Model execution
single_cals_modelled <- single_cals_modelled %>%
mutate(
offset_only_acc68 = map(data, offset_only_acc68),
sigma_only_acc68 = map(data, sigma_only_acc68),
offset_sigma_acc68 = map(data, offset_sigma_acc68),
offset_sigma_interact_acc68 = map(data, offset_sigma_interact_acc68),
offset_only_acc95 = map(data, offset_only_acc95),
sigma_only_acc95 = map(data, sigma_only_acc95),
offset_sigma_acc95 = map(data, offset_sigma_acc95),
offset_sigma_interact_acc95 = map(data, offset_sigma_interact_acc95)
)
###Change to 20 bins
single_cals_modelled_bin20 <- single_cals %>%
mutate (
offset_pos = if_else(offset_magnitude > 0, TRUE, FALSE),
offset_magnitude = if_else(offset_pos,
offset_magnitude, offset_magnitude * -1),
# Changing negs on offset magnitude to have a consistent direction at downstream visualization.
binned_targets = ntile(target_year, 20)
) %>%
select(-target_year)
### ntile() wouldn't return the relevant target years, so it needs to be done as its own thing.
single_cals_modelled_bin20 <- single_cals %>%
mutate(binned_targets = ntile(target_year, 20)) %>%
group_by(binned_targets) %>%
summarize( #Easy way to get years for the indiv bins, without too muchj headach
target_year = min(target_year)
) %>%
inner_join(single_cals_modelled_bin20) %>% #Join the binned DF back in. No, I don't like this either!
group_by(offset_pos, target_year) %>%
nest()
### Execute models
single_cals_modelled_bin20 <- single_cals_modelled_bin20 %>%
mutate(
offset_only_acc68 = map(data, offset_only_acc68),
sigma_only_acc68 = map(data, sigma_only_acc68),
offset_sigma_acc68 = map(data, offset_sigma_acc68),
offset_sigma_interact_acc68 = map(data, offset_sigma_interact_acc68),
offset_only_acc95 = map(data, offset_only_acc95),
sigma_only_acc95 = map(data, sigma_only_acc95),
offset_sigma_acc95 = map(data, offset_sigma_acc95),
offset_sigma_interact_acc95 = map(data, offset_sigma_interact_acc95)
)
### Extract the parameters
model_names_bin20 <- colnames(single_cals_modelled_bin20)[4:11] ##These will tell us what results go with what model
single_cals_log_results_bin20 <- data.frame()
single_cals_log_diagnostics_bin20 <- data.frame()
for (model in model_names) {
## This will get a little experimental - we are trying to create a big old table!
## First, we thin down the DF to the model of interest
temp_results <- single_cals_modelled_bin20 %>%
select(1, 2, all_of(model)) %>% #All of used to address deprecation
rename(glm_list = 3) %>% #This rename allows map to work correctly
mutate(
logistic_results = map(glm_list, tidy), # Do the map and also take note of which model
model = model
) %>%
select(-glm_list) %>% # Gets rid of the actual models (necessary for saving as csv)
unnest(logistic_results)# Unnests results
temp_diagnostics <- single_cals_modelled_bin20 %>% ## Similar to above
select(1, 2, all_of(model)) %>%
rename(glm_list = 3) %>%
mutate(
logistic_diagnostics = map(glm_list, glance),
model = model
) %>%
select(-glm_list) %>%
unnest(logistic_diagnostics)
single_cals_log_results_bin20 <- rbind(single_cals_log_results_bin20,
temp_results)
single_cals_log_diagnostics_bin20 <- rbind(single_cals_log_diagnostics_bin20,
temp_diagnostics)
}
single_cals_log_results_bin20 %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = model), alpha = 0.2, color = "grey75") +
geom_line(aes(color = model), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(colour = "grey80", size = 0.1),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", size = 0.5),
legend.position = "none",
strip.background = element_rect(
color="white", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue")) +
scale_color_manual(values = c("steelblue", "darkblue"))
###Change to 10 bins
single_cals_modelled_bin10 <- single_cals %>%
mutate (
offset_pos = if_else(offset_magnitude > 0, TRUE, FALSE),
offset_magnitude = if_else(offset_pos,
offset_magnitude, offset_magnitude * -1),
# Changing negs on offset magnitude to have a consistent direction at downstream visualization.
binned_targets = ntile(target_year, 10)
) %>%
select(-target_year)
### ntile() wouldn't return the relevant target years, so it needs to be done as its own thing.
single_cals_modelled_bin10 <- single_cals %>%
mutate(binned_targets = ntile(target_year, 10)) %>%
group_by(binned_targets) %>%
summarize( #Easy way to get years for the indiv bins, without too muchj headach
target_year = min(target_year)
) %>%
inner_join(single_cals_modelled_bin10) %>% #Join the binned DF back in. No, I don't like this either!
group_by(offset_pos, target_year) %>%
nest()
### Execute models
single_cals_modelled_bin10 <- single_cals_modelled_bin10 %>%
mutate(
offset_only_acc68 = map(data, offset_only_acc68),
sigma_only_acc68 = map(data, sigma_only_acc68),
offset_sigma_acc68 = map(data, offset_sigma_acc68),
offset_sigma_interact_acc68 = map(data, offset_sigma_interact_acc68),
offset_only_acc95 = map(data, offset_only_acc95),
sigma_only_acc95 = map(data, sigma_only_acc95),
offset_sigma_acc95 = map(data, offset_sigma_acc95),
offset_sigma_interact_acc95 = map(data, offset_sigma_interact_acc95)
)
### Extract the parameters
model_names_bin10 <- colnames(single_cals_modelled_bin10)[4:11] ##These will tell us what results go with what model
single_cals_log_results_bin10 <- data.frame()
single_cals_log_diagnostics_bin10 <- data.frame()
for (model in model_names) {
## This will get a little experimental - we are trying to create a big old table!
## First, we thin down the DF to the model of interest
temp_results <- single_cals_modelled_bin10 %>%
select(1, 2, all_of(model)) %>% #All of used to address deprecation
rename(glm_list = 3) %>% #This rename allows map to work correctly
mutate(
logistic_results = map(glm_list, tidy), # Do the map and also take note of which model
model = model
) %>%
select(-glm_list) %>% # Gets rid of the actual models (necessary for saving as csv)
unnest(logistic_results)# Unnests results
temp_diagnostics <- single_cals_modelled_bin10 %>% ## Similar to above
select(1, 2, all_of(model)) %>%
rename(glm_list = 3) %>%
mutate(
logistic_diagnostics = map(glm_list, glance),
model = model
) %>%
select(-glm_list) %>%
unnest(logistic_diagnostics)
single_cals_log_results_bin10 <- rbind(single_cals_log_results_bin10,
temp_results)
single_cals_log_diagnostics_bin10 <- rbind(single_cals_log_diagnostics_bin10,
temp_diagnostics)
}
single_cals_log_results_bin10 %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = model), alpha = 0.2, color = "grey75") +
geom_line(aes(color = model), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(colour = "grey80", size = 0.1),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", size = 0.5),
legend.position = "none",
strip.background = element_rect(
color="white", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue")) +
scale_color_manual(values = c("steelblue", "darkblue"))
single_cals_log_results_bin10 %>%
filter(str_detect(model, "interact") & str_detect(term, "Intercept")) %>%
mutate(
offset_pos = if_else(offset_pos, "Pos offset", "Neg offset"),
model = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = target_year, y = estimate)) +
geom_ribbon(aes(ymin = estimate - std.error * 2,
ymax = estimate + std.error * 2,
fill = model), alpha = 0.2, color = "grey75") +
geom_line(aes(color = model), linetype = "dotted") +
facet_grid(cols = vars(offset_pos), rows = vars(model), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
strip.background = element_rect(
color="black", fill="white"
),
text = element_text(family = "Corbel")
) +
scale_fill_manual(values = c("steelblue", "darkblue")) +
labs(
subtitle = "Intercept estimates from the models containing an interaction term",
x = "Target Date (Cal BP)"
)
## Get model diagnostics
### Set-up for fifty bins
singles_data_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/simulation_results/single_cals_curve_uncert_diag.csv"
single_cals <- read_csv(url(singles_data_url))
library(tidyverse)
library(broom)
## Get model diagnostics
### Set-up for fifty bins
model_diags_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/simulation_results/single_cals_curve_uncert_diag.csv"
model_diags <- read_csv(url(singles_data_url))
## Get model diagnostics
### Set-up for fifty bins
model_diags_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/model_results/single_cals_curve_uncert_diag.csv"
model_diags <- read_csv(url(singles_data_url))
model_diags <- read_csv(url(model_diags_url))
## Get model diagnostics
### Set-up for fifty bins
model_diags_url <- "https://raw.githubusercontent.com/pete-jacobsson/14C-power-sensitivity/main/model_results/single_cals_curve_uncert_diag.csv"
single_cals_curve_uncert_diag <- read_csv(url(model_diags_url))
single_cals_curve_uncert_diag %>%
mutate(
offset_direction = if_else(is_pos, "Positive", "Negative"),
hpd_area = if_else(str_detect(model, "68"), "68.2% HPD Area", "95.4% HPD Area"),
model = str_remove_all(model, "_acc\\d{2}")
) %>%
ggplot(aes(x = model, y = AIC)) +
geom_bar(stat = "identity", fill = "steelblue", color = "grey40") +
facet_grid(rows = vars(hpd_area), cols = vars(offset_direction), scales = "free") +
labs(
x = "Model",
subtitle = "AIC of different models that include curve uncertainty"
) +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", size = 0.5),
#legend.position = "none",
strip.background = element_rect(
color="white", fill="white"
),
text = element_text(family = "Corbel"),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 9)
)
